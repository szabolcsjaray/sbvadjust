// 1.08
var blocks = [];
var scrcontent;
var processedWords = 0;
var SBVloaded = false;


function printTestStr(str) {
    el("script").value = el("script").value + str;
}

function init() {
    let url = new URL(window.location.href);
    sessionLoad(true);
    initVideo();
    loadVideo(el("videoID").value);
    addKeyListener();
    enterListenerForVideoAddress();
    actualOp = TRANSLATION;
    el('operation').selectedIndex = actualOp;
    showAndHideControls();
    el('origFileSelect').addEventListener('change', loadOrigSBVFile);
    el('scriptFileSelect').addEventListener('change', loadScriptFile);
    window.addEventListener("beforeunload", function(event) {
        sessionSave(true);
    });

    if (url.searchParams.get('test')) {
        console.log(getRidOffMarks("Iti!?;"));
        console.log(getRidOffMarks("Itiner"));
        console.log(wmatches("7", "seven"));
        block0 = { "text": "try to parse these words", "index": 0, 'time': "0:0"};
        block1 = { "text": "ammd coontinue here. Some more sen-tences come here to make sure..", 'index': 1, 'time': "0:1"};
        block2 = { "text": "Third example section of the what we want.", 'index': 2, 'time': "0:2"};

        processedWords = 0;
        testScr = "Try to parse   these  w-ords   and  continue here. "+
                "Some more sentences come here to make sure.. "+
                "Third example section of the what we want.";
        el("script").value = "";
        scrcontent = testScr.split(' ');
        printTestStr("\n\nSrccontent length before:" + scrcontent.length + ", 1." + scrcontent[0] + " 24.:" + scrcontent[23]);
        filterEmptySrcWords();
        printTestStr("\n\nSrccontent length after filter:" + scrcontent.length + ", 1." + scrcontent[0] + " 24.:" + scrcontent[23]);
        let str = "\nTESTING...  \n\n"+testScr+"\n----------------------\n"+ blockToStr(block0)+"\n"+blockToStr(block1)+"\n";
        printTestStr(str);
        let res = processBlock(block0, block1, null, true);
        let res2 = processBlock(block1, block2, res, true);
        let res3 = processBlock(block2, null, res2, true);
        printTestStr("\nresult 1. block:\n"+ blockToStr(res) +
            "\nresult 2. block:\n" + blockToStr(res2) +
            "\nresult 3. block:\n" + blockToStr(res3));

        //alert(res.text);
    }
}

function blockToStr(block) {
    return "time: " + block.time +
        "\ntext: " + block.text +
        "\nnextText: "+((typeof block.nextText=='undefined')? "":block.nextText) +
        "\nnextI: "+block.nextI+
        "\n*********************************************************";
}
function el(id) {
    return document.getElementById(id);
}

function createHTMLForBlock(ind, blockTime, blockText, blockIndex, blockResText) {
    return "            <div class=\"block\" id=\"b"+ind+"\">"+
    (ind+1) + ". Time: <p id=\"ot"+ind+"\">"+ blockTime +"</p><br>" +
    "<textarea id=\"ob"+ind+"\" class=\"blockText\""+
    "onchange=\"refreshBlocksFromScreen();\" onclick=\"selectBlock("+ind+");\"" +
    ">"+
    blockText+
    "</textarea>"+
    "<textarea id=\"rb"+ind+"\" class=\"blockText resultBlock\" "+
    "onchange=\"refreshResultSBV();\"  onkeyup=\"blockEdited("+ind+");\"" +
    ">"+blockResText+"</textarea>" +
    "<div style=\"display:inline-block;width:3%;height:20px;position:relative;top:28px;\">"+
    "<img class=\"icon addIcons\" src=\"pics/plus.png\" title=\"Add missing words.\""+
    " onclick=\"addWords("+blockIndex+")\" style=\"width:100%;position:absolute;top:-70px;\"><br>"+
    "<img class=\"icon\" src=\"pics/target.png\" style=\"width:100%;position:absolute;top:-40px;\""+
        " title=\"Locate the block in the script.\" onclick=\"findBlock("+blockIndex+")\"/><br>" +
    "<img class=\"icon\" src=\"pics/play.png\" style=\"width:100%;top:-15px;position:absolute;\""+
        " title=\"Plays video with subs.\" onclick=\"playBlock("+blockIndex+")\"/>" +
    //"<img  class=\"icon\" src=\"pics/copy.png\" style=\"width:100%;top:50%;position:absolute;\""+
    //    " title=\"Copy the autogenerated block text to the script.\"/>" +
    "</div>" +
    "</div>";
}



function createOrigBlocks() {
    el("blocks").innerHTML = "";
    let newBlocks = "";
    let ind = 0;
    blocks.forEach( function(block) {
        newBlocks = newBlocks + createHTMLForBlock(ind, block.time, block.text, block.index, "");
        ind++;
    });
    el("blocks").innerHTML = newBlocks;
}

function loadOriginal(id) {
    checkWizard(id);
    blocks = [];
    let original = el("origSBV").value;
    let arrayOfLines = original.match(/[^\r\n]+/g);
    let bi = 0;
    for(let li = 0;li<arrayOfLines.length;) {
        arrayOfLines[li] = arrayOfLines[li].replace(/(\r\n)/g, " ");
        let block = {time: arrayOfLines[li]};
        li++; if (li>arrayOfLines.length) { break; }
        let text = arrayOfLines[li];
        li++;
        //console.log(arrayOfLines[li].match(/(\d:\d\d:\d\d)/));
        while(li<arrayOfLines.length && arrayOfLines[li].match(/(\d:\d\d:\d\d)/)==null) {
            text = text.trim() + " " + arrayOfLines[li];
            li++;
            //console.log(arrayOfLines[li].match(/(\d:\d\d:\d\d)/));
            if (li>arrayOfLines.length) { break; }

        }
        block.text = text;
        block.index = bi;
        bi = bi + 1;
        blocks.push(block);
    }

    createOrigBlocks();
    SBVloaded = true;

}

function getStartTime(timeStr) {
    return timeStr.substr(0,timeStr.indexOf(','));
}
function getEndTime(timeStr) {
    return timeStr.substr(timeStr.indexOf(',')+1);
}

function mergeBoxes() {
    let j = 0;
    for(let i = 0;i<blocks.length;i+=2) {
        if (i+1<blocks.length) {
            let starttime = getStartTime(blocks[i].time);
            if (getEndTime(blocks[i].time)<getStartTime(blocks[i+1].time)) {
                // just copy the original block, no merge, if separate blocks
                blocks[j].text = blocks[i].text;
                blocks[j].time = blocks[i].time;
                j++;
                i = i-1; //only step one forward inthis case
                continue;
            }
            let endtime = getEndTime(blocks[i+1].time);
            if (i+2<blocks.length) {
                let startTime_2;
                startTime_2 = getStartTime(blocks[i+2].time);
                if (endtime>startTime_2) {
                    endtime = startTime_2;
                }
            } else {
                let startTime_1;
                startTime_1 = getStartTime(blocks[i+1].time);
                if (endtime>startTime_1) {
                    endtime = startTime_1;
                }
            }
            blocks[j].text = blocks[i].text + ' ' + blocks[i+1].text;
            blocks[j].time = starttime + ','+endtime;
            console.log('start: ' + starttime + ' , endtime: '+endtime + ' | ' + blocks[j].text);
            j++;
        } else {
            blocks[j].text = blocks[i].text;
            blocks[j].time = blocks[i].time;
        }
    }
    while (j<blocks.length) {
        blocks.splice(j, 1);
    }
    createOrigBlocks();
}

const FIND_BLOCK_LEN = 30;

function findBlock(bi) {
    if (el("rb"+bi).startScriptPos!=-1) {
        selectInTextarea(el("script"), el("rb"+bi).startScriptPos, el("rb"+bi).endScriptPos, true);
    }
}

function findNextWordInScript(scriptPos, nextWord) {
    let start = el("script").value.substring(scriptPos).indexOf(nextWord);
    if (start==-1) {
        // we should never end up here
        console.log("ERROR: not found this word in script:" + nextWord + ", position:" + scriptPos);
        throw new Error();
    }
    return start + scriptPos;
}

function stepOverBlock(fromScriptPos, text) {
    let words = text.split(' ');
    let i = 0;
    let actScriptPos = fromScriptPos;
    while (i<words.length) {
        if (words[i].length>0) {
            actScriptPos = findNextWordInScript(actScriptPos, words[i]) + words[i].length;
        }
        i++;
    }
    return actScriptPos+1;
}

function refreshBlocksFromScreen() {
    for(let i=0;i<blocks.length;i++) {
        blocks[i].text=el("ob"+i).value.trim();
    }
}

const GOOD_FOR_ONE_LINE_LENGTH = 50;

const afterWord = ' .,:?!\'';

const wordsToCheck = [['mars', 'Mars'],
               ['earth', 'Earth'],
               ['venus', 'Venus'],
               ['moon', 'Moon']
            ];

function checkWords(str) {
    let newStr = str
    for(pair of wordsToCheck) {
        newStr = replaceWord(newStr, pair[0], pair[1]);
    }
    return newStr;
}

function replaceWord(str, from, to) {
    let newStr = str;
    for(ch of afterWord) {
        newStr = newStr.replaceAll(' '+from+ch, ' '+to+ch);
    }
    return newStr;
}

function refreshResultSBV() {
    let resLine = "";
    let i = 0;
    let lineEl = el("rb"+i);
    while (lineEl!=null) {
        let line = lineEl.value.trim();
        let lines = [line];

        if (line.length>GOOD_FOR_ONE_LINE_LENGTH) {
            let half = Math.round(line.length/2);
            halfFound = false;
            for(let li = half;li<line.length;li++) {
                if (line.charAt(li)==' ') {
                    lines[0] = line.substr(0,li);
                    lines[1] = line.substr(li);
                    halfFound = true;
                    break;
                }
            }
            if (!halfFound) {
                for(let li = half;li>0;li--) {
                    if (line.charAt(li)==' ') {
                        lines[0] = line.substr(0,li);
                        lines[1] = line.substr(li);
                        halfFound = true;
                        break;
                    }
                }
            }
            if (!halfFound) {
                lines[0] = line.substr(0,half);
                lines[1] = line.substr(half);
            }

            if (lines[0].length>57 || lines[1].length>57) {
                let third = Math.round(line.length/3);
                let twothird = Math.round(line.length*2/3);
                let firstSpace = line.indexOf(' ', third);
                let secondSpace = line.indexOf(' ', twothird);
                lines[0] = line.substr(0,firstSpace);
                lines[1] = line.substr(firstSpace+1, secondSpace-firstSpace-1);
                lines[2] = line.substr(secondSpace+1);
            }
        }
        if (line.length>0) {
            resLine = resLine + el("ot"+i).innerHTML + "\n";
            for (let lpi=0;lpi<lines.length;lpi++) {
                resLine += lines[lpi].trim() + "\n";
            }
            resLine += "\n";
        }
        i++;
        lineEl = el("rb"+i);
    }
    resLine = checkWords(resLine);
    el("resultSBV").value = resLine;
}

const EXACT_MATCH = 1;
const PARTIAL_MATCH = 2;
const DIFFERENT = 3;
const LOOK_FORWARD = 10;
const SIGNS=[',.:\''];
const NUMBERS=['ZERO', 'ONE', 'TWO', 'THREE', 'FOUR', 'FIVE', 'SIX', 'SEVEN', 'EIGHT', 'NINE'];
const MARKS="?!.:,;";

function getRidOffMarks(str) {
    i = str.length-1;
    while (i>0 && MARKS.includes(str[i])) {
        i--;
    }
    return str.substr(0,i+1);
}

function wmatches(srcWord, blockWord) {
    let dword1 = getRidOffMarks(srcWord.toUpperCase());
    let dword2 = getRidOffMarks(blockWord.toUpperCase());
    if (dword1==dword2) {
        return EXACT_MATCH;
    } else if ((NUMBERS.indexOf(dword1)!=-1 && ""+NUMBERS.indexOf(dword1)==dword2) ||
            (NUMBERS.indexOf(dword2)!=-1 && ""+NUMBERS.indexOf(dword2)==dword1)) {
        return EXACT_MATCH;
    } else {
        let dl1 = dword1.length;
        let dl2 = dword2.length;
        let i = 0;
        let diff = [];
        //print("match:" + dword1 +"|"+ dword2)
        while (i<dword1.length && i<dword2.length) {
            if (dword1[i]!=dword2[i]) {
                diff.push(i);
            }

            i = i + 1;
        }
        //print(diff)


        if (dword1.length==dword2.length+1) {
            if (i==dword2.length && diff.length==0) {
                return PARTIAL_MATCH;
            }
        }

        if (dword2.length==dword1.length+1) {
            if (i==dword1.length && diff.length==0) {
                return PARTIAL_MATCH;
            }
        }

        if (diff.length==1 && i>2) {
            return PARTIAL_MATCH;
        }


        if (dl1>dl2) {
            if (dl2==1 && diff.length>0) {
                return DIFFERENT;
            }
            if (dl1>dl2+2) {
                return DIFFERENT;
            }
            if (diff.length==1 && diff[0]==dl2-1) {
                return PARTIAL_MATCH;
            }
        } else if (dl2>dl1 && dl1>2) {
            if (dl1==1 && diff.length>0) {
                return DIFFERENT;
            }
            if (dl2>dl1+2) {
                return DIFFERENT;
            }
            if (diff.length==1 && diff[0]==dl1-1) {
                return PARTIAL_MATCH;
            }
        } else if (diff.length==1 && diff[0]==dl1-1 && dl1>2) {
            return PARTIAL_MATCH;
        }

        if (i>2 && diff.length<dl1*0.3 && diff.length<dl2*0.3) {
            return PARTIAL_MATCH;
        }

        return DIFFERENT;
    }
}

function selectInTextarea(tarea, startPos, endPos, scrollTo = false) {
    if(typeof(tarea.selectionStart) != "undefined") {
        tarea.focus();
        if (scrollTo) {
            const fullText = tarea.value;
            tarea.value = fullText.substring(0, endPos);
            tarea.scrollTop = tarea.scrollHeight;
            tarea.value = fullText;
        }
        tarea.selectionStart = startPos;
        tarea.selectionEnd = endPos;
        return true;
    }

    // IE
    if (document.selection && document.selection.createRange) {
        tarea.focus();
        tarea.select();
        var range = document.selection.createRange();
        range.collapse(true);
        range.moveEnd("character", endPos);
        range.moveStart("character", startPos);
        range.select();
        return true;
    }
}

function logCollect(logStr, newLogStr, toConsole) {
    logStr = logStr + newLogStr;
    if (toConsole) {
        console.log(newLogStr);
    }
    return logStr;
}
const NEXTWORD_IS_BW_PLUS_ABW = 20;
const NEXTWORD_IS_BW_HYPHEN_ABW = 21;
const BLOCKWORD_IS_NW_PLUS_ANW = 22;
const BLOCKWORD_IS_NW_HYPHEN_ANW = 23;
const SAME_WITH_HYPHEN = 24;

function sameWithAHyphenDiff(word1, word2) {
    let i1 = 0;
    let i2 = 0;
    let hyphen = false;
    while (i1<word1.length && i2<word2.length) {
        if (word1[i1]=='-') {
            if (hyphen) {
                return false; // too much hyphen
            } else {
                i1++;
                hyphen = true;
            }
        }
        if (word2[i2]=='-') {
            if (hyphen) {
                return false; // too much hyphen
            } else {
                i2++;
                hyphen = true;
            }
        }
        if (word1[i1]!=word2[i2]) {
            return false; // not the same letters
        }
        i1++;
        i2++;
    }
    return (i1==word1.length && i2==word2.length);
}

function checkHyphenAndAttachedWords(nextWord, afterNextWord, blockWord, afterBlockWord) {
    let nextWordU = nextWord.toUpperCase();
    let afterNextWordU = (afterNextWord!=null ? afterNextWord.toUpperCase() : null);
    let blockWordU = blockWord.toUpperCase();
    let afterBlockWordU = afterBlockWord.toUpperCase();
    if (nextWordU.startsWith(blockWordU)) {
        if ((nextWordU.length==blockWordU.length + afterBlockWordU.length) &&
            (nextWordU.lastIndexOf(afterBlockWordU)==blockWordU.length)) {
                return NEXTWORD_IS_BW_PLUS_ABW;
            }
        if ((nextWordU.length==blockWordU.length + afterBlockWordU.length + 1) &&
            (nextWordU.lastIndexOf(afterBlockWordU)==blockWordU.length+1) &&
            nextWordU[blockWordU.length]=='-') {
            return NEXTWORD_IS_BW_HYPHEN_ABW;
        }
    }
    if (afterNextWord!=null && blockWordU.startsWith(nextWordU)) {
        if ((blockWordU.length==nextWordU.length + afterNextWordU.length) &&
            (blockWordU.lastIndexOf(afterNextWordU)==nextWordU.length)) {
                return BLOCKWORD_IS_NW_PLUS_ANW;
            }
        if ((blockWordU.length==nextWordU.length + afterNextWordU.length + 1) &&
        (blockWordU.lastIndexOf(afterNextWordU)==nextWordU.length + 1) &&
            blockWordU[nextWordU.length]=='-') {
            return BLOCKWORD_IS_NW_HYPHEN_ANW;
        }
    }
    if (nextWordU.length==blockWordU.length+1 ||
        nextWordU.length==blockWordU.length-1) {
        if (sameWithAHyphenDiff(nextWordU, blockWordU)) {
            return SAME_WITH_HYPHEN;
        }
    }
    return DIFFERENT;
}

function processBlock(block, nextBlock, prevResBlock = null, debugOn = false) {
    let resTextLine = "";
    let separator = "";
    console.log("Processing block: " + block.time);
    let blockWords = block.text.split(' ');
    let twoBlockWords = (nextBlock!=null ? block.text.split(' ').concat(nextBlock.text.split(' ')) : block.text.split(' '));
    let blockWordI = 0;
    let startWord = processedWords;
    let iLog = "Processing block: " + block.time + "\n";
    let newBlock = { 'last': false, 'lostSync' : false, nextText : ''};
    if (prevResBlock!=null) {
        newBlock.text = prevResBlock.nextText + (prevResBlock.nextText.length>0 ? " " : "");
        blockWordI = prevResBlock.nextI + 1;
        console.log("Transferred text: "+ newBlock.text + "\n blockWordI = " + (prevResBlock.nextI + 1))
    } else {
        newBlock.text = "";
    }
    let startPos = 0;
    let collectedNextContentPart = "";
    let nextI = -1;
    while (blockWordI<blockWords.length) {
        let blockWord = blockWords[blockWordI];


        if (processedWords>=scrcontent.length) {
            newBlock.last = true;
            break;
        }
        while (processedWords<scrcontent.length-1 && scrcontent[processedWords].length==0) {
            processedWords++;
        }
        let nextWord = scrcontent[processedWords];
        processedWords++;
        collectedNextContentPart = "";
        nextI = -1;

        iLog = logCollect(iLog, "Check block|content: " + blockWord + "|" + nextWord + "\n", debugOn);
        //console.log("Check block|content: " + blockWord + "|" + nextWord)
        match = wmatches(nextWord, blockWord);
        if (match==EXACT_MATCH) {
            resTextLine = resTextLine + separator + nextWord;
            iLog = logCollect(iLog, "Exact match (block|content): " + blockWord + "|" + nextWord + "\n", debugOn);
            //console.log("Exact match (block|content): " + blockWord + "|" + nextWord)
        } else if (match==PARTIAL_MATCH) {
            iLog = logCollect(iLog, "Partial match (block|content): " + blockWord + "|" + nextWord + "\n", debugOn);
            //console.log("Partial match (block|content): " + blockWord + "|" + nextWord)
            resTextLine = resTextLine + separator + nextWord;
        } else {
            match = checkHyphenAndAttachedWords(nextWord,
                (processedWords<scrcontent.length ? scrcontent[processedWords] : null),
                blockWord,
                twoBlockWords[blockWordI+1]);
                /*const NEXTWORD_IS_BW_PLUS_ABW = 20;
                const NEXTWORD_IS_BW_HYPHEN_ABW = 21;
                const BLOCKWORD_IS_NW_PLUS_ANW = 22;
                const BLOCKWORD_IS_NW_HYPHEN_ANW = 23;*/
            if (match==NEXTWORD_IS_BW_PLUS_ABW || match==NEXTWORD_IS_BW_HYPHEN_ABW) {
                iLog = logCollect(iLog, "Concatenated word (block|content): " + blockWord + twoBlockWords[blockWordI+1] + "|" + nextWord + "\n", debugOn);
                resTextLine = resTextLine + separator + nextWord;
                blockWordI++;
            } else if (match==BLOCKWORD_IS_NW_HYPHEN_ANW || match==BLOCKWORD_IS_NW_PLUS_ANW) {
                iLog = logCollect(iLog, "Concatenated word (block|content): " + blockWord + "|" + nextWord + scrcontent[processedWords] + "\n", debugOn);
                resTextLine = resTextLine + separator + nextWord + separator + scrcontent[processedWords];
                processedWords++;
            } else if (match==SAME_WITH_HYPHEN) {
                iLog = logCollect(iLog, "Same with hypen (block|content): " + blockWord  + "|" + nextWord + "\n", debugOn);
                resTextLine = resTextLine + separator + nextWord;
            } else {

                iLog = logCollect(iLog, "Problem here (block|content):" + blockWord + "|" + nextWord + "\n", debugOn);
                //console.log("Problem here (block|content):" + blockWord + "|" + nextWord)

                let syncs = [];
                let startPosBadWord = startPos;
                let badBlockWord = blockWord;
                let blockWordProblemI = blockWordI;
                let foundSync = false;
                while (foundSync==false && blockWordI<twoBlockWords.length && blockWordI-blockWordProblemI<LOOK_FORWARD) {
                    blockWord = twoBlockWords[blockWordI];
                    iLog = logCollect(iLog, "Try to find sync for this block word:" + blockWord +"\n", debugOn);
                    //console.log("Try to find sync for this block word:" + blockWord)
                    let findI = processedWords-1;
                    let collectContentPart = "";
                    collectedNextContentPart = "";
                    while (findI<scrcontent.length && findI<processedWords+LOOK_FORWARD &&
                            (wmatches(scrcontent[findI], blockWord)==DIFFERENT)) {
                        iLog = logCollect(iLog,  "Try sync, no match:" + scrcontent[findI] + "!=" + blockWord + "\n", debugOn);
                        //console.log("Try sync, no match:" + content[findI] + "!=" + blockWord)
                        if (findI-processedWords<blockWords.length-blockWordProblemI-1) {
                            collectContentPart = collectContentPart + separator + scrcontent[findI];
                        } else {
                            collectedNextContentPart = collectedNextContentPart + separator + scrcontent[findI];
                        }
                        separator = " ";
                        findI = findI + 1;
                    }
                    if (findI>=processedWords+LOOK_FORWARD) {
                        blockWordI = blockWordI + 1;
                        iLog = logCollect(iLog, "Step blockWordI"  + "\n", false);
                        //console.log("Step blockWordI")
                    } else {
                        iLog = logCollect(iLog, "Found sync: " + scrcontent[findI]  + "==" + blockWord  + "\n", debugOn);
                        //console.log("Found sync: " + scrcontent[findI]  + "==" + blockWord)

                        if (findI-processedWords<blockWords.length-blockWordProblemI-1) {
                            collectContentPart = collectContentPart + separator + scrcontent[findI];
                        } else {
                            collectedNextContentPart = collectedNextContentPart + separator + scrcontent[findI];
                        }
                        sync = {'findI': findI,
                                'blockWordI' : blockWordI,
                                'collectContentPart': collectContentPart,
                                'collectedNextContentPart' : collectedNextContentPart};
                        syncs.push(sync);
                        blockWordI = blockWordI + 1;
                        startPos = startPos + blockWord.length + 1;
                        //foundSync = True
                    }
                }

                if (syncs.length==0) {
                    console.log(iLog);
                    console.log("Not found sync till end of block or "+
                        LOOK_FORWARD+" words, word:" + nextWord +
                        ", block word:" + badBlockWord +". Block is:" + block['time']);
                    console.log("Old block:" + block['text']);
                    selectInTextarea( el("ob"+block.index), startPosBadWord, startPosBadWord+badBlockWord.length);
                    let i = processedWords;
                    contentFrom = "";
                    while (i<processedWords+10 && i<scrcontent.length) {
                        contentFrom = contentFrom + scrcontent[i] + " ";
                        i = i + 1;
                    }
                    console.log("Content from:" + contentFrom);
                    newBlock.lostSync = true;
                    alert("Sync lost. Bad block word:" + badBlockWord);
                    el("stopped").innerHTML = badBlockWord;
                    return newBlock; // !!!!!!
                } else {
                    //console.log("Syncs num: " , len(syncs))
                    if (syncs-length!=1) {
                        //console.log("Sync only: --------")
                        //for k,v in sync.iteritems():
                        //    console.log(k , v)
                        //console.log("----------")
                        //else:
                        sync = syncs[0]

                        for(let i=1;i<syncs.length;i++) {
                            if (syncs[i]['findI']<sync['findI']) {
                                sync = syncs[i];
                                /*
                                //console.log("Sync: --------")
                                //for k,v in sync.iteritems():
                                //    console.log(k , v)
                                console.log("----------")
                                */
                            }
                        }
                    }
                    processedWords = sync['findI'] + 1;
                    iLog = logCollect(iLog, "Apply sync, add this to new block:" + sync['collectContentPart'] + "\n", debugOn);
                    blockWordI = sync['blockWordI'];
                    if (blockWordI>=blockWords.length) {
                        nextI = blockWordI - blockWords.length;
                        //alert("over the block! i:" + blockWordI + "\n collected next part:" + sync['collectedNextContentPart'] +
                        //    "\n nextI:" + nextI);
                        collectedNextContentPart = sync['collectedNextContentPart'];
                        /*newBlock.lostSync = true;
                        alert("Sync lost. Bad block word:" + badBlockWord);
                        return newBlock;*/
                    } else {
                        collectedNextContentPart = "";
                    }
                    resTextLine = resTextLine + sync['collectContentPart'];
                    iLog = logCollect(iLog, "result so far:" + resTextLine + "\n", debugOn);
                    if (blockWordI<twoBlockWords.length-1) {
                        iLog = logCollect(iLog, "next block word:" + blockWords[blockWordI+1] + "\n", debugOn);
                    }
                    //logf.write(iLog.encode('utf-8') + "\n")
                    //logf.write("\n\n")
                    //console.log("result so far:" + resTextLine)
                }
            }
        }
        separator = " ";
        blockWordI = blockWordI + 1;
        startPos = startPos + blockWord.length + 1;
    }

    console.log("New block text:" + resTextLine);
    console.log("Old block text:" + block.text);
    if (resTextLine.split(' ').length!=block.text.split(' ').length) {
        console.log('------------------------------!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!---------------------------------------------');
    }
    let usedWords = "";
    for(let i=startWord;i<processedWords;i++) {
        usedWords = usedWords + scrcontent[i] + " ";
    }
    console.log("Used words    :" + usedWords);
    console.log("---------------------------------------------------");
    newBlock.time = block.time.trim();
    newBlock.text = newBlock.text + resTextLine.trim();
    newBlock.nextText = collectedNextContentPart;
    newBlock.nextI = nextI;
    return newBlock;
}

function createResultSBV(resBlocksLoc) {
    resLine = "";
    resBlocksLoc.forEach(function(block) {
        if (block.time === undefined || block.text === undefined) {
            return;
        }
        resLine = resLine + block.time.trim() + "\n" + block.text.trim() + "\n\n";
    });
    el("resultSBV").value = resLine;
}

function filterEmptySrcWords() {
    let i = 0;
    while (i<scrcontent.length) {
        if (scrcontent[i].length==0) {
            srccontent = scrcontent.splice(i,1);
        } else {
            i++;
        }
    }
}

function processSBV(id) {
    checkWizard(id);

    if (!SBVloaded) {
        loadOriginal();
    }
    processedWords = 0;
    scrcontent = []
    //console.log(el("script").value.replace(/\n\r/g, " "));
    scrcontent = el("script").value.replace(/\n\r/g, " ")
                    .replace(/\n/g, ' ')
                    .replace(/  /g, ' ')
                    .replace(/  /g, ' ')
                    .replace(/  /g, ' ')
                    .split(' ');
    filterEmptySrcWords();
    let resBlocksLoc = [];
    let bi = 0;
    let scrollTo = -1;
    let blockScriptPos = 0;
    for(bi=0;bi<blocks.length;bi++) {
        let startBlockScriptPos = blockScriptPos;
        resBlocksLoc[bi] = processBlock(blocks[bi],
            (bi+1<blocks.length ? blocks[bi+1] : null),
            (bi>0 ? resBlocksLoc[bi-1] : null));
            if (resBlocksLoc[bi].nextText.length>0) {
                console.log("This is transferred: " + resBlocksLoc[bi].nextText);
            console.log("blcokWordI in next block: " +resBlocksLoc[bi].nextI);
        }
        if (resBlocksLoc[bi].lostSync) {
            scrollTo = bi;
            console.log("Lost synchronization.. Correct sources, and rerun process!");
            break;
        }
        if (resBlocksLoc[bi].last) {
            scrollTo = bi;
            console.log('All script is processed.');
            alert("Whole script is processed!");
            break;
        }

        el("rb"+bi).value = resBlocksLoc[bi].text;
        resBlocksLoc[bi].startScriptPos = blockScriptPos;
        blockScriptPos = stepOverBlock(blockScriptPos, resBlocksLoc[bi].text);
        resBlocksLoc[bi].endScriptPos = blockScriptPos;
        el("rb"+bi).startScriptPos = resBlocksLoc[bi].startScriptPos;
        el("rb"+bi).endScriptPos = resBlocksLoc[bi].endScriptPos;

        let wordNoOrig = blocks[bi].text.split(' ').length;
        let wordNoRes = resBlocksLoc[bi].text.split(' ').length;
        let wordNoDiff = Math.abs(wordNoOrig-wordNoRes);
        if (wordNoDiff>0) {
            if (wordNoDiff<=2) {
                el("b"+bi).style.borderRight="4px solid orange";
                blocks[bi].mark = 'orange';
            } else {
                el("b"+bi).style.borderRight="5px solid red";
                blocks[bi].mark = 'red';
            }
        } else {
            el("b"+bi).style.borderRight="4px solid green";
            blocks[bi].mark = 'green';
        }
        el("rb"+bi).style.backgroundColor = "blanchedalmond";
    }


    for(let i=resBlocksLoc.length-1;i<blocks.length;i++) {
        el("rb"+i).style.backgroundColor = "";
        el("b"+i).style.borderRight="5px solid red";
        el("rb"+i).startScriptPos = -1;
    }

    if (scrollTo==-1) {
        scrollTo = block.length;
    }
    if (scrollTo>0) {
        scrollTo--;
    }
    el("blocks").scrollTop = el("ob"+scrollTo).offsetTop - el("blocks").offsetTop;
    createResultSBV(resBlocksLoc);
    refreshResultSBV();
}


function isBlockRed(bi) {
    return 'mark' in blocks[bi] && blocks[bi].mark=="red";
}

function changeOnlyRed() {
    if (el("onlyRed").checked) {
        for(let bi=0;bi<blocks.length;bi++) {
            if ( !isBlockRed(bi) &&
                (bi==0 || !isBlockRed(bi-1)) &&
                (bi>=blocks.length-1 || !isBlockRed(bi+1)) ) {
               el("b"+bi).style.display = "none";
            }
        }
    } else {
        for(let bi=0;bi<blocks.length;bi++) {
             el("b"+bi).style.display = "block";
        }
    }
}


function loadTranslatedBlocks(id) {
    checkWizard(id);
    if (blocks.length==0) {
        if (SBVloaded) {
            loadOriginal();
        } else {
            alert("Load the original SBV first (top left text area)!");
            return;
        }
    }
    resBlocksLoc = [];
    let original = el("script").value;
    let arrayOfLines = original.match(/[^\r\n]+/g);
    let bi = 0;
    for(let li = 0;li<arrayOfLines.length;) {
        arrayOfLines[li] = arrayOfLines[li].replace(/(\r\n)/g, " ");
        let block = {time: arrayOfLines[li]};
        li++; if (li>arrayOfLines.length) { break; }
        let text = arrayOfLines[li];
        li++;
        while(li<arrayOfLines.length && arrayOfLines[li].match(/^(\d:)/)==null) {
            text = text + " " + arrayOfLines[li];
            li++;
            if (li>arrayOfLines.length) { break; }
        }
        block.text = text;
        block.index = bi;
        bi = bi + 1;
        resBlocksLoc.push(block);
    }

    let ind = 0;
    resBlocksLoc.forEach( function(block) {
        el('rb'+ind).value = block.text;
        ind++;
    });
    refreshResultSBV();
}

function addWords(blockI) {
    let orig = el('ob'+blockI).value;
    let result = el('rb'+blockI).value;
    let origA = orig.split(' ');
    let resA = result.split(' ');
    console.log("before");
    console.log(origA.join(' '));
    console.log(resA.join(' '));
    let origI = 0;
    let resI = 0;
    while (origI<origA.length) {

        while (origI<origA.length && resI<resA.length && wmatches(origA[origI], resA[resI])!=DIFFERENT) {
            origI++;
            resI++;
        }
        console.log("o:" + origI + ", r:" + resI);
        if (origI<origA.length) {
            resA.splice(resI, 0, origA[origI]);
            resI++;
            origI++;
        }
        console.log("Added and o:" + origI + ", r:" + resI);
    }
    let diff = resA.join(' ').length - el('rb'+blockI).value.length;
    let ok = confirm("Auto: \n"+ origA.join(' ') +
        "\n After:\n"+ resA.join(' ') +
        "\n(before:\n"+ el('rb'+blockI).value +
        "\n diff:" + diff + ")");
    if (ok) {
        el('rb'+blockI).value = resA.join(' ');
        let scr = el("script").value;
        let newScr = scr.substring(0, el('rb'+blockI).startScriptPos) + resA.join(' ') +
            ' ' + scr.substring(el('rb'+blockI).endScriptPos);
        el("script").value = newScr;
        el('rb'+blockI).endScriptPos += diff;
        let i = blockI+1;
        let bl = el('rb'+i);
        while( bl!=null) {
            if (bl.startScriptPos!=null) {
                bl.startScriptPos += diff;
            }
            if ( bl.endScriptPos!=null) {
                bl.endScriptPos += diff;
            }
            i++;
            bl = el('rb'+i);
        }
    }
}